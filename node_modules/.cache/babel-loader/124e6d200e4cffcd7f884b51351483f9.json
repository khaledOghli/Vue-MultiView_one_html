{"ast":null,"code":"import { toRefs, watch, nextTick, computed } from 'composition-api';\nexport default function usePointer(props, context, dep) {\n  const {\n    valueProp,\n    showOptions,\n    searchable,\n    groupLabel,\n    groups: groupped,\n    mode,\n    groupSelect\n  } = toRefs(props); // ============ DEPENDENCIES ============\n\n  const fo = dep.fo;\n  const fg = dep.fg;\n  const handleOptionClick = dep.handleOptionClick;\n  const handleGroupClick = dep.handleGroupClick;\n  const search = dep.search;\n  const pointer = dep.pointer;\n  const setPointer = dep.setPointer;\n  const clearPointer = dep.clearPointer;\n  const multiselect = dep.multiselect; // ============== COMPUTED ==============\n  // no export\n\n  const options = computed(() => {\n    return fo.value.filter(o => !o.disabled);\n  });\n  const groups = computed(() => {\n    return fg.value.filter(o => !o.disabled);\n  });\n  const canPointGroups = computed(() => {\n    return mode.value !== 'single' && groupSelect.value;\n  });\n  const isPointerGroup = computed(() => {\n    return pointer.value && pointer.value.group;\n  });\n  const currentGroup = computed(() => {\n    return getParentGroup(pointer.value);\n  });\n  const prevGroup = computed(() => {\n    const group = isPointerGroup.value ? pointer.value :\n    /* istanbul ignore next */\n    getParentGroup(pointer.value);\n    const groupIndex = groups.value.map(g => g[groupLabel.value]).indexOf(group[groupLabel.value]);\n    let prevGroup = groups.value[groupIndex - 1];\n\n    if (prevGroup === undefined) {\n      prevGroup = lastGroup.value;\n    }\n\n    return prevGroup;\n  });\n  const nextGroup = computed(() => {\n    let nextIndex = groups.value.map(g => g.label).indexOf(isPointerGroup.value ? pointer.value[groupLabel.value] : getParentGroup(pointer.value)[groupLabel.value]) + 1;\n\n    if (groups.value.length <= nextIndex) {\n      nextIndex = 0;\n    }\n\n    return groups.value[nextIndex];\n  });\n  const lastGroup = computed(() => {\n    return [...groups.value].slice(-1)[0];\n  });\n  const currentGroupFirstEnabledOption = computed(() => {\n    return pointer.value.__VISIBLE__.filter(o => !o.disabled)[0];\n  });\n  const currentGroupPrevEnabledOption = computed(() => {\n    const options = currentGroup.value.__VISIBLE__.filter(o => !o.disabled);\n\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1];\n  });\n  const currentGroupNextEnabledOption = computed(() => {\n    const options = getParentGroup(pointer.value).__VISIBLE__.filter(o => !o.disabled);\n\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1];\n  });\n  const prevGroupLastEnabledOption = computed(() => {\n    return [...prevGroup.value.__VISIBLE__.filter(o => !o.disabled)].slice(-1)[0];\n  });\n  const lastGroupLastEnabledOption = computed(() => {\n    return [...lastGroup.value.__VISIBLE__.filter(o => !o.disabled)].slice(-1)[0];\n  }); // =============== METHODS ==============\n\n  const isPointed = option => {\n    return !!pointer.value && (!option.group && pointer.value[valueProp.value] == option[valueProp.value] || option.group !== undefined && pointer.value[groupLabel.value] == option[groupLabel.value]) ? true : undefined;\n  };\n\n  const setPointerFirst = () => {\n    setPointer(options.value[0] || null);\n  };\n\n  const selectPointer = () => {\n    if (!pointer.value || pointer.value.disabled === true) {\n      return;\n    }\n\n    if (isPointerGroup.value) {\n      handleGroupClick(pointer.value);\n    } else {\n      handleOptionClick(pointer.value);\n    }\n  };\n\n  const forwardPointer = () => {\n    if (pointer.value === null) {\n      setPointer((groupped.value && canPointGroups.value ? groups.value[0] : options.value[0]) || null);\n    } else if (groupped.value && canPointGroups.value) {\n      let nextPointer = isPointerGroup.value ? currentGroupFirstEnabledOption.value : currentGroupNextEnabledOption.value;\n\n      if (nextPointer === undefined) {\n        nextPointer = nextGroup.value;\n      }\n\n      setPointer(nextPointer ||\n      /* istanbul ignore next */\n      null);\n    } else {\n      let next = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1;\n\n      if (options.value.length <= next) {\n        next = 0;\n      }\n\n      setPointer(options.value[next] || null);\n    }\n\n    nextTick(() => {\n      adjustWrapperScrollToPointer();\n    });\n  };\n\n  const backwardPointer = () => {\n    if (pointer.value === null) {\n      let prevPointer = options.value[options.value.length - 1];\n\n      if (groupped.value && canPointGroups.value) {\n        prevPointer = lastGroupLastEnabledOption.value;\n\n        if (prevPointer === undefined) {\n          prevPointer = lastGroup.value;\n        }\n      }\n\n      setPointer(prevPointer || null);\n    } else if (groupped.value && canPointGroups.value) {\n      let prevPointer = isPointerGroup.value ? prevGroupLastEnabledOption.value : currentGroupPrevEnabledOption.value;\n\n      if (prevPointer === undefined) {\n        prevPointer = isPointerGroup.value ? prevGroup.value : currentGroup.value;\n      }\n\n      setPointer(prevPointer ||\n      /* istanbul ignore next */\n      null);\n    } else {\n      let prevIndex = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1;\n\n      if (prevIndex < 0) {\n        prevIndex = options.value.length - 1;\n      }\n\n      setPointer(options.value[prevIndex] || null);\n    }\n\n    nextTick(() => {\n      adjustWrapperScrollToPointer();\n    });\n  };\n\n  const getParentGroup = option => {\n    return groups.value.find(group => {\n      return group.__VISIBLE__.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1;\n    });\n  }; // no export\n\n  /* istanbul ignore next */\n\n\n  const adjustWrapperScrollToPointer = () => {\n    let pointedOption = multiselect.value.querySelector(`[data-pointed]`);\n\n    if (!pointedOption) {\n      return;\n    }\n\n    let wrapper = pointedOption.parentElement.parentElement;\n\n    if (groupped.value) {\n      wrapper = isPointerGroup.value ? pointedOption.parentElement.parentElement.parentElement : pointedOption.parentElement.parentElement.parentElement.parentElement;\n    }\n\n    if (pointedOption.offsetTop + pointedOption.offsetHeight > wrapper.clientHeight + wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop + pointedOption.offsetHeight - wrapper.clientHeight;\n    }\n\n    if (pointedOption.offsetTop < wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop;\n    }\n  }; // ============== WATCHERS ==============\n\n\n  watch(search, val => {\n    if (searchable.value) {\n      if (val.length && showOptions.value) {\n        setPointerFirst();\n      } else {\n        clearPointer();\n      }\n    }\n  });\n  return {\n    pointer,\n    canPointGroups,\n    isPointed,\n    setPointerFirst,\n    selectPointer,\n    forwardPointer,\n    backwardPointer\n  };\n}","map":{"version":3,"sources":["/Users/khaledoghli/Desktop/webpack/vue-js/hello-js/node_modules/@vueform/multiselect/src/composables/usePointerAction.js"],"names":["toRefs","watch","nextTick","computed","usePointer","props","context","dep","valueProp","showOptions","searchable","groupLabel","groups","groupped","mode","groupSelect","fo","fg","handleOptionClick","handleGroupClick","search","pointer","setPointer","clearPointer","multiselect","options","value","filter","o","disabled","canPointGroups","isPointerGroup","group","currentGroup","getParentGroup","prevGroup","groupIndex","map","g","indexOf","undefined","lastGroup","nextGroup","nextIndex","label","length","slice","currentGroupFirstEnabledOption","__VISIBLE__","currentGroupPrevEnabledOption","currentGroupNextEnabledOption","prevGroupLastEnabledOption","lastGroupLastEnabledOption","isPointed","option","setPointerFirst","selectPointer","forwardPointer","nextPointer","next","adjustWrapperScrollToPointer","backwardPointer","prevPointer","prevIndex","find","pointedOption","querySelector","wrapper","parentElement","offsetTop","offsetHeight","clientHeight","scrollTop","val"],"mappings":"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","sourcesContent":["import { toRefs, watch, nextTick, computed } from 'composition-api'\n\nexport default function usePointer (props, context, dep)\n{\n  const {\n    valueProp, showOptions, searchable, groupLabel,\n    groups: groupped, mode, groupSelect,\n  } = toRefs(props)\n\n  // ============ DEPENDENCIES ============\n\n  const fo = dep.fo\n  const fg = dep.fg\n  const handleOptionClick = dep.handleOptionClick\n  const handleGroupClick = dep.handleGroupClick\n  const search = dep.search\n  const pointer = dep.pointer\n  const setPointer = dep.setPointer\n  const clearPointer = dep.clearPointer\n  const multiselect = dep.multiselect\n\n  // ============== COMPUTED ==============\n\n  // no export\n  const options = computed(() => {\n    return fo.value.filter(o => !o.disabled)\n  })\n\n  const groups = computed(() => {\n    return fg.value.filter(o => !o.disabled)\n  })\n\n  const canPointGroups = computed(() => {\n    return mode.value !== 'single' && groupSelect.value\n  })\n\n  const isPointerGroup = computed(() => {\n    return pointer.value && pointer.value.group\n  })\n\n  const currentGroup = computed(() => {\n    return getParentGroup(pointer.value)\n  })\n\n  const prevGroup = computed(() => {\n    const group = isPointerGroup.value ? pointer.value : /* istanbul ignore next */ getParentGroup(pointer.value)\n    const groupIndex = groups.value.map(g => g[groupLabel.value]).indexOf(group[groupLabel.value])\n    let prevGroup = groups.value[groupIndex - 1]\n\n    if (prevGroup === undefined) {\n      prevGroup = lastGroup.value\n    }\n\n    return prevGroup\n  })\n  \n  const nextGroup = computed(() => {\n    let nextIndex = groups.value.map(g => g.label).indexOf(isPointerGroup.value\n      ? pointer.value[groupLabel.value]\n      : getParentGroup(pointer.value)[groupLabel.value]) + 1\n\n    if (groups.value.length <= nextIndex) {\n      nextIndex = 0\n    }\n\n    return groups.value[nextIndex]\n  })\n\n  const lastGroup = computed(() => {\n    return [...groups.value].slice(-1)[0]\n  })\n  \n  const currentGroupFirstEnabledOption = computed(() => {\n    return pointer.value.__VISIBLE__.filter(o => !o.disabled)[0]\n  })\n\n  const currentGroupPrevEnabledOption = computed(() => {\n    const options = currentGroup.value.__VISIBLE__.filter(o => !o.disabled)\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1]\n  })\n  \n  const currentGroupNextEnabledOption = computed(() => {\n    const options = getParentGroup(pointer.value).__VISIBLE__.filter(o => !o.disabled)\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1]\n  })\n\n  const prevGroupLastEnabledOption = computed(() => {\n    return [...prevGroup.value.__VISIBLE__.filter(o => !o.disabled)].slice(-1)[0]\n  })\n\n  const lastGroupLastEnabledOption = computed(() => {\n    return [...lastGroup.value.__VISIBLE__.filter(o => !o.disabled)].slice(-1)[0]\n  })\n\n  // =============== METHODS ==============\n\n  const isPointed = (option) => {\n    return (!!pointer.value && (\n      (!option.group && pointer.value[valueProp.value] == option[valueProp.value]) ||\n      (option.group !== undefined && pointer.value[groupLabel.value] == option[groupLabel.value])\n    )) ? true : undefined\n  }\n\n  const setPointerFirst = () => {\n    setPointer(options.value[0] || null)\n  }\n\n  const selectPointer = () => {\n    if (!pointer.value || pointer.value.disabled === true) {\n      return\n    }\n\n    if (isPointerGroup.value) {\n      handleGroupClick(pointer.value)\n    } else {\n      handleOptionClick(pointer.value)\n    }\n  }\n\n  const forwardPointer = () => {\n    if (pointer.value === null) {\n      setPointer((groupped.value && canPointGroups.value ? groups.value[0] : options.value[0]) || null)\n    }\n    else if (groupped.value && canPointGroups.value) {\n      let nextPointer = isPointerGroup.value ? currentGroupFirstEnabledOption.value : currentGroupNextEnabledOption.value\n\n      if (nextPointer === undefined) {\n        nextPointer = nextGroup.value\n      }\n\n      setPointer(nextPointer || /* istanbul ignore next */ null)\n    } else {\n      let next = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1\n\n      if (options.value.length <= next) {\n        next = 0\n      }\n\n      setPointer(options.value[next] || null)\n    }\n\n    nextTick(() => {\n      adjustWrapperScrollToPointer()\n    })\n  }\n\n  const backwardPointer = () => {\n    if (pointer.value === null) {\n      let prevPointer = options.value[options.value.length - 1]\n\n      if (groupped.value && canPointGroups.value) {\n        prevPointer = lastGroupLastEnabledOption.value\n\n        if (prevPointer === undefined) {\n          prevPointer = lastGroup.value\n        }\n      }\n\n      setPointer(prevPointer  || null)\n    }\n    else if (groupped.value && canPointGroups.value) {\n      let prevPointer = isPointerGroup.value ? prevGroupLastEnabledOption.value : currentGroupPrevEnabledOption.value\n\n      if (prevPointer === undefined) {\n        prevPointer = isPointerGroup.value ? prevGroup.value : currentGroup.value\n      }\n\n      setPointer(prevPointer || /* istanbul ignore next */ null)\n    } else {\n      let prevIndex = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1\n\n      if (prevIndex < 0) {\n        prevIndex = options.value.length - 1\n      }\n\n      setPointer(options.value[prevIndex] || null)\n    }\n\n    nextTick(() => {\n      adjustWrapperScrollToPointer()\n    })\n  }\n\n  const getParentGroup = (option) => {\n    return groups.value.find((group) => {\n      return group.__VISIBLE__.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1\n    })\n  }\n\n  // no export\n  /* istanbul ignore next */\n  const adjustWrapperScrollToPointer = () => {\n    let pointedOption = multiselect.value.querySelector(`[data-pointed]`)\n\n    if (!pointedOption) {\n      return\n    }\n\n    let wrapper = pointedOption.parentElement.parentElement\n\n    if (groupped.value) {\n      wrapper = isPointerGroup.value\n        ? pointedOption.parentElement.parentElement.parentElement\n        : pointedOption.parentElement.parentElement.parentElement.parentElement\n    }\n\n    if (pointedOption.offsetTop + pointedOption.offsetHeight > wrapper.clientHeight + wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop + pointedOption.offsetHeight - wrapper.clientHeight\n    }\n    \n    if (pointedOption.offsetTop < wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop\n    }\n  }\n\n  // ============== WATCHERS ==============\n\n  watch(search, (val) => {\n    if (searchable.value) {\n      if (val.length && showOptions.value) {\n        setPointerFirst()\n      } else {\n        clearPointer()\n      }\n    }\n  })\n\n  return {\n    pointer,\n    canPointGroups,\n    isPointed,\n    setPointerFirst,\n    selectPointer,\n    forwardPointer,\n    backwardPointer,\n  }\n}"]},"metadata":{},"sourceType":"module"}