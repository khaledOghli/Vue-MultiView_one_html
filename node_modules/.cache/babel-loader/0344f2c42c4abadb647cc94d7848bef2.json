{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { ref, toRefs, computed, watch, nextTick } from 'composition-api';\nimport normalize from './../utils/normalize';\nimport isObject from './../utils/isObject';\nimport isNullish from './../utils/isNullish';\nimport arraysEqual from './../utils/arraysEqual';\nexport default function useOptions(props, context, dep) {\n  const {\n    options,\n    mode,\n    trackBy: trackBy_,\n    limit,\n    hideSelected,\n    createTag,\n    createOption: createOption_,\n    label,\n    appendNewTag,\n    appendNewOption: appendNewOption_,\n    multipleLabel,\n    object,\n    loading,\n    delay,\n    resolveOnLoad,\n    minChars,\n    filterResults,\n    clearOnSearch,\n    clearOnSelect,\n    valueProp,\n    canDeselect,\n    max,\n    strict,\n    closeOnSelect,\n    groups: groupped,\n    groupLabel,\n    groupOptions,\n    groupHideEmpty,\n    groupSelect\n  } = toRefs(props); // ============ DEPENDENCIES ============\n\n  const iv = dep.iv;\n  const ev = dep.ev;\n  const search = dep.search;\n  const clearSearch = dep.clearSearch;\n  const update = dep.update;\n  const pointer = dep.pointer;\n  const clearPointer = dep.clearPointer;\n  const blur = dep.blur;\n  const focus = dep.focus;\n  const deactivate = dep.deactivate; // ================ DATA ================\n  // no export\n  // appendedOptions\n\n  const ap = ref([]); // no export\n  // resolvedOptions\n\n  const ro = ref([]);\n  const resolving = ref(false); // ============== COMPUTED ==============\n  // no export\n\n  const createOption = computed(() => {\n    return createTag.value || createOption_.value || false;\n  }); // no export\n\n  const appendNewOption = computed(() => {\n    if (appendNewTag.value !== undefined) {\n      return appendNewTag.value;\n    } else if (appendNewOption_.value !== undefined) {\n      return appendNewOption_.value;\n    }\n\n    return true;\n  }); // no export\n  // extendedOptions\n\n  const eo = computed(() => {\n    if (groupped.value) {\n      let groups = ro.value ||\n      /* istanbul ignore next */\n      [];\n      let eo = [];\n      groups.forEach(group => {\n        optionsToArray(group[groupOptions.value]).forEach(option => {\n          eo.push(Object.assign({}, option, group.disabled ? {\n            disabled: true\n          } : {}));\n        });\n      });\n      return eo;\n    } else {\n      let eo = optionsToArray(ro.value || []);\n\n      if (ap.value.length) {\n        eo = eo.concat(ap.value);\n      }\n\n      return eo;\n    }\n  });\n  const fg = computed(() => {\n    if (!groupped.value) {\n      return [];\n    }\n\n    return filterGroups((ro.value ||\n    /* istanbul ignore next */\n    []).map(group => {\n      const arrayOptions = optionsToArray(group[groupOptions.value]);\n      return { ...group,\n        group: true,\n        [groupOptions.value]: filterOptions(arrayOptions, false).map(o => Object.assign({}, o, group.disabled ? {\n          disabled: true\n        } : {})),\n        __VISIBLE__: filterOptions(arrayOptions).map(o => Object.assign({}, o, group.disabled ? {\n          disabled: true\n        } : {}))\n      }; // Difference between __VISIBLE__ and {groupOptions}: visible does not contain selected options when hideSelected=true\n    }));\n  }); // filteredOptions\n\n  const fo = computed(() => {\n    let options = eo.value;\n\n    if (createdOption.value.length) {\n      options = createdOption.value.concat(options);\n    }\n\n    options = filterOptions(options);\n\n    if (limit.value > 0) {\n      options = options.slice(0, limit.value);\n    }\n\n    return options;\n  });\n  const hasSelected = computed(() => {\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value[valueProp.value]);\n\n      case 'multiple':\n      case 'tags':\n        return !isNullish(iv.value) && iv.value.length > 0;\n    }\n  });\n  const multipleLabelText = computed(() => {\n    return multipleLabel !== undefined && multipleLabel.value !== undefined ? multipleLabel.value(iv.value) : iv.value && iv.value.length > 1 ? `${iv.value.length} options selected` : `1 option selected`;\n  });\n  const noOptions = computed(() => {\n    return !eo.value.length && !resolving.value && !createdOption.value.length;\n  });\n  const noResults = computed(() => {\n    return eo.value.length > 0 && fo.value.length == 0 && (search.value && groupped.value || !groupped.value);\n  }); // no export\n\n  const createdOption = computed(() => {\n    if (createOption.value === false || !search.value) {\n      return [];\n    }\n\n    return getOptionByTrackBy(search.value) !== -1 ? [] : [{\n      [valueProp.value]: search.value,\n      [label.value]: search.value,\n      [trackBy.value]: search.value\n    }];\n  });\n  const trackBy = computed(() => {\n    return trackBy_.value || label.value;\n  }); // no export\n\n  const nullValue = computed(() => {\n    switch (mode.value) {\n      case 'single':\n        return null;\n\n      case 'multiple':\n      case 'tags':\n        return [];\n    }\n  });\n  const busy = computed(() => {\n    return loading.value || resolving.value;\n  }); // =============== METHODS ==============\n\n  /**\n   * @param {array|object|string|number} option \n   */\n\n  const select = option => {\n    if (typeof option !== 'object') {\n      option = getOption(option);\n    }\n\n    switch (mode.value) {\n      case 'single':\n        update(option);\n        break;\n\n      case 'multiple':\n      case 'tags':\n        update(iv.value.concat(option));\n        break;\n    }\n\n    context.emit('select', finalValue(option), option);\n  };\n\n  const deselect = option => {\n    if (typeof option !== 'object') {\n      option = getOption(option);\n    }\n\n    switch (mode.value) {\n      case 'single':\n        clear();\n        break;\n\n      case 'tags':\n      case 'multiple':\n        update(Array.isArray(option) ? iv.value.filter(v => option.map(o => o[valueProp.value]).indexOf(v[valueProp.value]) === -1) : iv.value.filter(v => v[valueProp.value] != option[valueProp.value]));\n        break;\n    }\n\n    context.emit('deselect', finalValue(option), option);\n  }; // no export\n\n\n  const finalValue = option => {\n    return object.value ? option : option[valueProp.value];\n  };\n\n  const remove = option => {\n    deselect(option);\n  };\n\n  const handleTagRemove = (option, e) => {\n    if (e.button !== 0) {\n      e.preventDefault();\n      return;\n    }\n\n    remove(option);\n  };\n\n  const clear = () => {\n    context.emit('clear');\n    update(nullValue.value);\n  };\n\n  const isSelected = option => {\n    if (option.group !== undefined) {\n      return mode.value === 'single' ? false : areAllSelected(option[groupOptions.value]) && option[groupOptions.value].length;\n    }\n\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value) && iv.value[valueProp.value] == option[valueProp.value];\n\n      case 'tags':\n      case 'multiple':\n        return !isNullish(iv.value) && iv.value.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1;\n    }\n  };\n\n  const isDisabled = option => {\n    return option.disabled === true;\n  };\n\n  const isMax = () => {\n    if (max === undefined || max.value === -1 || !hasSelected.value && max.value > 0) {\n      return false;\n    }\n\n    return iv.value.length >= max.value;\n  };\n\n  const handleOptionClick = option => {\n    if (isDisabled(option)) {\n      return;\n    }\n\n    switch (mode.value) {\n      case 'single':\n        if (isSelected(option)) {\n          if (canDeselect.value) {\n            deselect(option);\n          }\n\n          return;\n        }\n\n        handleOptionAppend(option);\n        blur();\n        select(option);\n        break;\n\n      case 'multiple':\n        if (isSelected(option)) {\n          deselect(option);\n          return;\n        }\n\n        if (isMax()) {\n          return;\n        }\n\n        handleOptionAppend(option);\n        select(option);\n\n        if (clearOnSelect.value) {\n          clearSearch();\n        }\n\n        if (hideSelected.value) {\n          clearPointer();\n        } // If we need to close the dropdown on select we also need\n        // to blur the input, otherwise further searches will not\n        // display any options\n\n\n        if (closeOnSelect.value) {\n          blur();\n        }\n\n        break;\n\n      case 'tags':\n        if (isSelected(option)) {\n          deselect(option);\n          return;\n        }\n\n        if (isMax()) {\n          return;\n        }\n\n        handleOptionAppend(option);\n\n        if (clearOnSelect.value) {\n          clearSearch();\n        }\n\n        select(option);\n\n        if (hideSelected.value) {\n          clearPointer();\n        } // If we need to close the dropdown on select we also need\n        // to blur the input, otherwise further searches will not\n        // display any options\n\n\n        if (closeOnSelect.value) {\n          blur();\n        }\n\n        break;\n    }\n\n    if (closeOnSelect.value) {\n      deactivate();\n    } else {\n      focus();\n    }\n  };\n\n  const handleGroupClick = group => {\n    if (isDisabled(group) || mode.value === 'single' || !groupSelect.value) {\n      return;\n    }\n\n    switch (mode.value) {\n      case 'multiple':\n      case 'tags':\n        if (areAllEnabledSelected(group[groupOptions.value])) {\n          deselect(group[groupOptions.value]);\n        } else {\n          select(group[groupOptions.value].filter(o => iv.value.map(v => v[valueProp.value]).indexOf(o[valueProp.value]) === -1).filter(o => !o.disabled).filter((o, k) => iv.value.length + 1 + k <= max.value || max.value === -1));\n        }\n\n        break;\n    }\n\n    if (closeOnSelect.value) {\n      deactivate();\n    }\n  };\n\n  const handleOptionAppend = option => {\n    if (getOption(option[valueProp.value]) === undefined && createOption.value) {\n      context.emit('tag', option[valueProp.value]);\n      context.emit('option', option[valueProp.value]);\n\n      if (appendNewOption.value) {\n        appendOption(option);\n      }\n\n      clearSearch();\n    }\n  };\n\n  const selectAll = () => {\n    if (mode.value === 'single') {\n      return;\n    }\n\n    select(fo.value);\n  }; // no export\n\n\n  const areAllEnabledSelected = options => {\n    return options.find(o => !isSelected(o) && !o.disabled) === undefined;\n  }; // no export\n\n\n  const areAllSelected = options => {\n    return options.find(o => !isSelected(o)) === undefined;\n  };\n\n  const getOption = val => {\n    return eo.value[eo.value.map(o => String(o[valueProp.value])).indexOf(String(val))];\n  }; // no export\n\n\n  const getOptionByTrackBy = (val, norm = true) => {\n    return eo.value.map(o => o[trackBy.value]).indexOf(val);\n  }; // no export\n\n\n  const shouldHideOption = option => {\n    return ['tags', 'multiple'].indexOf(mode.value) !== -1 && hideSelected.value && isSelected(option);\n  }; // no export\n\n\n  const appendOption = option => {\n    ap.value.push(option);\n  }; // no export\n\n\n  const filterGroups = groups => {\n    // If the search has value we need to filter among \n    // he ones that are visible to the user to avoid\n    // displaying groups which technically have options\n    // based on search but that option is already selected.\n    return groupHideEmpty.value ? groups.filter(g => search.value ? g.__VISIBLE__.length : g[groupOptions.value].length) : groups.filter(g => search.value ? g.__VISIBLE__.length : true);\n  }; // no export\n\n\n  const filterOptions = (options, excludeHideSelected = true) => {\n    let fo = options;\n\n    if (search.value && filterResults.value) {\n      fo = fo.filter(option => {\n        return normalize(option[trackBy.value], strict.value).indexOf(normalize(search.value, strict.value)) !== -1;\n      });\n    }\n\n    if (hideSelected.value && excludeHideSelected) {\n      fo = fo.filter(option => !shouldHideOption(option));\n    }\n\n    return fo;\n  }; // no export\n\n\n  const optionsToArray = options => {\n    let uo = options; // Transforming an object to an array of objects\n\n    if (isObject(uo)) {\n      uo = Object.keys(uo).map(key => {\n        let val = uo[key];\n        return {\n          [valueProp.value]: key,\n          [trackBy.value]: val,\n          [label.value]: val\n        };\n      });\n    } // Transforming an plain arrays to an array of objects\n\n\n    uo = uo.map(val => {\n      return typeof val === 'object' ? val : {\n        [valueProp.value]: val,\n        [trackBy.value]: val,\n        [label.value]: val\n      };\n    });\n    return uo;\n  }; // no export\n\n\n  const initInternalValue = () => {\n    if (!isNullish(ev.value)) {\n      iv.value = makeInternal(ev.value);\n    }\n  };\n\n  const resolveOptions = callback => {\n    resolving.value = true;\n    options.value(search.value).then(response => {\n      ro.value = response;\n\n      if (typeof callback == 'function') {\n        callback(response);\n      }\n\n      resolving.value = false;\n    });\n  }; // no export\n\n\n  const refreshLabels = () => {\n    if (!hasSelected.value) {\n      return;\n    }\n\n    if (mode.value === 'single') {\n      let newLabel = getOption(iv.value[valueProp.value])[label.value];\n      iv.value[label.value] = newLabel;\n\n      if (object.value) {\n        ev.value[label.value] = newLabel;\n      }\n    } else {\n      iv.value.forEach((val, i) => {\n        let newLabel = getOption(iv.value[i][valueProp.value])[label.value];\n        iv.value[i][label.value] = newLabel;\n\n        if (object.value) {\n          ev.value[i][label.value] = newLabel;\n        }\n      });\n    }\n  };\n\n  const refreshOptions = callback => {\n    resolveOptions(callback);\n  }; // no export\n\n\n  const makeInternal = val => {\n    if (isNullish(val)) {\n      return mode.value === 'single' ? {} : [];\n    }\n\n    if (object.value) {\n      return val;\n    } // If external should be plain transform\n    // value object to plain values\n\n\n    return mode.value === 'single' ? getOption(val) || {} : val.filter(v => !!getOption(v)).map(v => getOption(v));\n  }; // ================ HOOKS ===============\n\n\n  if (mode.value !== 'single' && !isNullish(ev.value) && !Array.isArray(ev.value)) {\n    throw new Error(`v-model must be an array when using \"${mode.value}\" mode`);\n  }\n\n  if (options && typeof options.value == 'function') {\n    if (resolveOnLoad.value) {\n      resolveOptions(initInternalValue);\n    } else if (object.value == true) {\n      initInternalValue();\n    }\n  } else {\n    ro.value = options.value;\n    initInternalValue();\n  } // ============== WATCHERS ==============\n\n\n  if (delay.value > -1) {\n    watch(search, query => {\n      if (query.length < minChars.value) {\n        return;\n      }\n\n      resolving.value = true;\n\n      if (clearOnSearch.value) {\n        ro.value = [];\n      }\n\n      setTimeout(() => {\n        if (query != search.value) {\n          return;\n        }\n\n        options.value(search.value).then(response => {\n          if (query == search.value || !search.value) {\n            ro.value = response;\n            pointer.value = fo.value.filter(o => o.disabled !== true)[0] || null;\n            resolving.value = false;\n          }\n        });\n      }, delay.value);\n    }, {\n      flush: 'sync'\n    });\n  }\n\n  watch(ev, newValue => {\n    if (isNullish(newValue)) {\n      iv.value = makeInternal(newValue);\n      return;\n    }\n\n    switch (mode.value) {\n      case 'single':\n        if (object.value ? newValue[valueProp.value] != iv.value[valueProp.value] : newValue != iv.value[valueProp.value]) {\n          iv.value = makeInternal(newValue);\n        }\n\n        break;\n\n      case 'multiple':\n      case 'tags':\n        if (!arraysEqual(object.value ? newValue.map(o => o[valueProp.value]) : newValue, iv.value.map(o => o[valueProp.value]))) {\n          iv.value = makeInternal(newValue);\n        }\n\n        break;\n    }\n  }, {\n    deep: true\n  });\n\n  if (typeof props.options !== 'function') {\n    watch(options, (n, o) => {\n      ro.value = props.options;\n\n      if (!Object.keys(iv.value).length) {\n        initInternalValue();\n      }\n\n      refreshLabels();\n    });\n  }\n\n  return {\n    fo,\n    filteredOptions: fo,\n    hasSelected,\n    multipleLabelText,\n    eo,\n    extendedOptions: eo,\n    fg,\n    filteredGroups: fg,\n    noOptions,\n    noResults,\n    resolving,\n    busy,\n    select,\n    deselect,\n    remove,\n    selectAll,\n    clear,\n    isSelected,\n    isDisabled,\n    isMax,\n    getOption,\n    handleOptionClick,\n    handleGroupClick,\n    handleTagRemove,\n    refreshOptions,\n    resolveOptions\n  };\n}","map":{"version":3,"sources":["/Users/khaledoghli/Desktop/webpack/vue-js/hello-js/node_modules/@vueform/multiselect/src/composables/useOptions.js"],"names":["ref","toRefs","computed","watch","nextTick","normalize","isObject","isNullish","arraysEqual","useOptions","props","context","dep","options","mode","trackBy","trackBy_","limit","hideSelected","createTag","createOption","createOption_","label","appendNewTag","appendNewOption","appendNewOption_","multipleLabel","object","loading","delay","resolveOnLoad","minChars","filterResults","clearOnSearch","clearOnSelect","valueProp","canDeselect","max","strict","closeOnSelect","groups","groupped","groupLabel","groupOptions","groupHideEmpty","groupSelect","iv","ev","search","clearSearch","update","pointer","clearPointer","blur","focus","deactivate","ap","ro","resolving","value","undefined","eo","forEach","group","optionsToArray","option","push","Object","assign","disabled","length","concat","fg","filterGroups","map","arrayOptions","filterOptions","o","__VISIBLE__","fo","createdOption","slice","hasSelected","multipleLabelText","noOptions","noResults","getOptionByTrackBy","nullValue","busy","select","getOption","emit","finalValue","deselect","clear","Array","isArray","filter","v","indexOf","remove","handleTagRemove","e","button","preventDefault","isSelected","areAllSelected","isDisabled","isMax","handleOptionClick","handleOptionAppend","handleGroupClick","areAllEnabledSelected","k","appendOption","selectAll","find","val","String","norm","shouldHideOption","g","excludeHideSelected","uo","keys","key","initInternalValue","makeInternal","resolveOptions","callback","then","response","refreshLabels","newLabel","i","refreshOptions","Error","query","setTimeout","flush","newValue","deep","n","filteredOptions","extendedOptions","filteredGroups"],"mappings":"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","sourcesContent":["import { ref, toRefs, computed, watch, nextTick } from 'composition-api'\nimport normalize from './../utils/normalize'\nimport isObject from './../utils/isObject'\nimport isNullish from './../utils/isNullish'\nimport arraysEqual from './../utils/arraysEqual'\n\nexport default function useOptions (props, context, dep)\n{\n  const { \n    options, mode, trackBy: trackBy_, limit, hideSelected, createTag, createOption: createOption_, label,\n    appendNewTag, appendNewOption: appendNewOption_, multipleLabel, object, loading, delay, resolveOnLoad,\n    minChars, filterResults, clearOnSearch, clearOnSelect, valueProp,\n    canDeselect, max, strict, closeOnSelect, groups: groupped, groupLabel,\n    groupOptions, groupHideEmpty, groupSelect, \n  } = toRefs(props)\n\n  // ============ DEPENDENCIES ============\n\n  const iv = dep.iv\n  const ev = dep.ev\n  const search = dep.search\n  const clearSearch = dep.clearSearch\n  const update = dep.update\n  const pointer = dep.pointer\n  const clearPointer = dep.clearPointer\n  const blur = dep.blur\n  const focus = dep.focus\n  const deactivate = dep.deactivate\n\n  // ================ DATA ================\n\n  // no export\n  // appendedOptions\n  const ap = ref([])\n\n  // no export\n  // resolvedOptions\n  const ro = ref([])\n\n  const resolving = ref(false)\n\n  // ============== COMPUTED ==============\n\n  // no export\n  const createOption = computed(() => {\n    return createTag.value || createOption_.value || false\n  })\n\n  // no export\n  const appendNewOption = computed(() => {\n    if (appendNewTag.value !== undefined) {\n      return appendNewTag.value\n    } else if (appendNewOption_.value !== undefined) {\n      return appendNewOption_.value\n    }\n\n    return true\n  })\n\n  // no export\n  // extendedOptions\n  const eo = computed(() => {\n    if (groupped.value) {\n      let groups = ro.value || /* istanbul ignore next */ []\n\n      let eo = []\n\n      groups.forEach((group) => {\n        optionsToArray(group[groupOptions.value]).forEach((option) => {\n          eo.push(Object.assign({}, option, group.disabled ? { disabled: true } : {}))\n        })\n      })\n\n      return eo\n    } else {\n      let eo = optionsToArray(ro.value || [])\n\n      if (ap.value.length) {\n        eo = eo.concat(ap.value)\n      }\n\n      return eo\n    }\n  })\n\n  const fg = computed(() => {\n    if (!groupped.value) {\n      return []\n    }\n\n    return filterGroups((ro.value || /* istanbul ignore next */ []).map((group) => {\n      const arrayOptions = optionsToArray(group[groupOptions.value])\n\n      return {\n        ...group,\n        group: true,\n        [groupOptions.value]: filterOptions(arrayOptions, false).map(o => Object.assign({}, o, group.disabled ? { disabled: true } : {})),\n        __VISIBLE__: filterOptions(arrayOptions).map(o => Object.assign({}, o, group.disabled ? { disabled: true } : {})),\n      }\n      // Difference between __VISIBLE__ and {groupOptions}: visible does not contain selected options when hideSelected=true\n    }))\n  })\n\n  // filteredOptions\n  const fo = computed(() => {\n    let options = eo.value\n\n    if (createdOption.value.length) {\n      options = createdOption.value.concat(options)\n    }\n\n    options = filterOptions(options)\n\n    if (limit.value > 0) {\n      options = options.slice(0, limit.value)\n    }\n\n    return options\n  })\n\n  const hasSelected = computed(() => {\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value[valueProp.value])\n\n      case 'multiple':\n      case 'tags':\n        return !isNullish(iv.value) && iv.value.length > 0\n    }\n  })\n\n  const multipleLabelText = computed(() => {\n    return multipleLabel !== undefined && multipleLabel.value !== undefined\n      ? multipleLabel.value(iv.value)\n      : (iv.value && iv.value.length > 1 ? `${iv.value.length} options selected` : `1 option selected`)\n  })\n\n  const noOptions = computed(() => {\n    return !eo.value.length && !resolving.value && !createdOption.value.length\n  })\n\n\n  const noResults = computed(() => {\n    return eo.value.length > 0 && fo.value.length == 0 && ((search.value && groupped.value) || !groupped.value)\n  })\n\n  // no export\n  const createdOption = computed(() => {\n    if (createOption.value === false || !search.value) {\n      return []\n    }\n\n    return getOptionByTrackBy(search.value) !== -1 ? [] : [{\n      [valueProp.value]: search.value,\n      [label.value]: search.value,\n      [trackBy.value]: search.value,\n    }]\n  })\n\n  const trackBy = computed(() => {\n    return trackBy_.value || label.value\n  })\n\n  // no export\n  const nullValue = computed(() => {\n    switch (mode.value) {\n      case 'single':\n        return null\n\n      case 'multiple':\n      case 'tags':\n        return []\n    }\n  })\n\n  const busy = computed(() => {\n    return loading.value || resolving.value\n  })\n\n  // =============== METHODS ==============\n\n  /**\n   * @param {array|object|string|number} option \n   */\n  const select = (option) => {\n    if (typeof option !== 'object') {\n      option = getOption(option)\n    }\n\n    switch (mode.value) {\n      case 'single':\n        update(option)\n        break\n\n      case 'multiple':\n      case 'tags':\n        update((iv.value).concat(option))\n        break\n    }\n\n    context.emit('select', finalValue(option), option)\n  }\n\n  const deselect = (option) => {\n    if (typeof option !== 'object') {\n      option = getOption(option)\n    }\n\n    switch (mode.value) {\n      case 'single':\n        clear()\n        break\n\n      case 'tags':\n      case 'multiple':\n        update(Array.isArray(option)\n          ? iv.value.filter(v => option.map(o => o[valueProp.value]).indexOf(v[valueProp.value]) === -1)\n          : iv.value.filter(v => v[valueProp.value] != option[valueProp.value]))\n        break\n    }\n\n    context.emit('deselect', finalValue(option), option)\n  }\n\n  // no export\n  const finalValue = (option) => {\n    return object.value ? option : option[valueProp.value]\n  }\n\n  const remove = (option) => {\n    deselect(option)\n  }\n\n  const handleTagRemove = (option, e) => {\n    if (e.button !== 0) {\n      e.preventDefault()\n      return\n    }\n\n    remove(option)\n  }\n\n  const clear = () => {\n    context.emit('clear')\n    update(nullValue.value)\n  }\n\n  const isSelected = (option) => {\n    if (option.group !== undefined) {\n      return mode.value === 'single' ? false : areAllSelected(option[groupOptions.value]) && option[groupOptions.value].length\n    }\n\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value) && iv.value[valueProp.value] == option[valueProp.value]\n\n      case 'tags':\n      case 'multiple':\n        return !isNullish(iv.value) && iv.value.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1\n    }\n  }\n\n  const isDisabled = (option) => {\n    return option.disabled === true\n  }\n\n  const isMax = () => {\n    if (max === undefined || max.value === -1 || (!hasSelected.value && max.value > 0)) {\n      return false\n    }\n    \n    return iv.value.length >= max.value\n  }\n\n  const handleOptionClick = (option) => {\n    if (isDisabled(option)) {\n      return\n    }\n\n    switch (mode.value) {\n      case 'single':\n        if (isSelected(option)) {\n          if (canDeselect.value) {\n            deselect(option)\n          }\n          return\n        }\n\n        handleOptionAppend(option)\n\n        blur()\n        select(option)\n        break\n\n      case 'multiple':\n        if (isSelected(option)) {\n          deselect(option)\n          return\n        }\n\n        if (isMax()) {\n          return\n        }\n\n        handleOptionAppend(option)\n\n        select(option)\n\n        if (clearOnSelect.value) {\n          clearSearch()\n        }\n\n        if (hideSelected.value) {\n          clearPointer()\n        }\n\n        // If we need to close the dropdown on select we also need\n        // to blur the input, otherwise further searches will not\n        // display any options\n        if (closeOnSelect.value) {\n          blur()\n        }\n        break\n\n      case 'tags':\n        if (isSelected(option)) {\n          deselect(option)\n          return\n        }\n\n        if (isMax()) {\n          return\n        }\n\n        handleOptionAppend(option)\n\n        if (clearOnSelect.value) {\n          clearSearch()\n        }\n\n        select(option)\n\n        if (hideSelected.value) {\n          clearPointer()\n        }\n\n        // If we need to close the dropdown on select we also need\n        // to blur the input, otherwise further searches will not\n        // display any options\n        if (closeOnSelect.value) {\n          blur()\n        }\n        break\n    }\n\n    if (closeOnSelect.value) {\n      deactivate()\n    } else {\n      focus()\n    }\n  }\n\n  const handleGroupClick = (group) => {\n    if (isDisabled(group) || mode.value === 'single' || !groupSelect.value) {\n      return\n    }\n\n    switch (mode.value) {\n      case 'multiple':\n      case 'tags':\n        if (areAllEnabledSelected(group[groupOptions.value])) {\n          deselect(group[groupOptions.value])\n        } else {\n          select(group[groupOptions.value]\n            .filter(o => iv.value.map(v => v[valueProp.value]).indexOf(o[valueProp.value]) === -1)\n            .filter(o => !o.disabled)\n            .filter((o, k) => iv.value.length + 1 + k <= max.value || max.value === -1)\n          )\n        }\n        break\n    }\n\n    if (closeOnSelect.value) {\n      deactivate()\n    }\n  }\n\n  const handleOptionAppend = (option) => {\n    if (getOption(option[valueProp.value]) === undefined && createOption.value) {\n      context.emit('tag', option[valueProp.value])\n      context.emit('option', option[valueProp.value])\n\n      if (appendNewOption.value) {\n        appendOption(option)\n      }\n\n      clearSearch()\n    }\n  }\n\n  const selectAll = () => {\n    if (mode.value === 'single') {\n      return\n    }\n\n    select(fo.value)\n  }\n\n  // no export\n  const areAllEnabledSelected = (options) => {\n    return options.find(o => !isSelected(o) && !o.disabled) === undefined\n  }\n\n  // no export\n  const areAllSelected = (options) => {\n    return options.find(o => !isSelected(o)) === undefined\n  }\n\n  const getOption = (val) => {\n    return eo.value[eo.value.map(o => String(o[valueProp.value])).indexOf(String(val))]\n  }\n\n  // no export\n  const getOptionByTrackBy = (val, norm = true) => {\n    return eo.value.map(o => o[trackBy.value]).indexOf(val)\n  }\n\n  // no export\n  const shouldHideOption = (option) => {\n    return ['tags', 'multiple'].indexOf(mode.value) !== -1 && hideSelected.value && isSelected(option)\n  }\n\n  // no export\n  const appendOption = (option) => {\n    ap.value.push(option)\n  }\n\n  // no export\n  const filterGroups = (groups) => {\n    // If the search has value we need to filter among \n    // he ones that are visible to the user to avoid\n    // displaying groups which technically have options\n    // based on search but that option is already selected.\n    return groupHideEmpty.value\n      ? groups.filter(g => search.value\n          ? g.__VISIBLE__.length\n          : g[groupOptions.value].length\n        )\n      : groups.filter(g => search.value ? g.__VISIBLE__.length : true)\n  }\n\n  // no export\n  const filterOptions = (options, excludeHideSelected = true) => {\n    let fo = options\n    \n    if (search.value && filterResults.value) {\n      fo = fo.filter((option) => {\n        return normalize(option[trackBy.value], strict.value).indexOf(normalize(search.value, strict.value)) !== -1\n      })\n    }\n\n    if (hideSelected.value && excludeHideSelected) {\n      fo = fo.filter((option) => !shouldHideOption(option))\n    }\n\n    return fo\n  }\n\n  // no export\n  const optionsToArray = (options) => {\n    let uo = options\n    \n    // Transforming an object to an array of objects\n    if (isObject(uo)) {\n      uo = Object.keys(uo).map((key) => {\n        let val = uo[key]\n\n        return { [valueProp.value]: key, [trackBy.value]: val, [label.value]: val}\n      })\n    }\n\n    // Transforming an plain arrays to an array of objects\n    uo = uo.map((val) => {\n      return typeof val === 'object' ? val : { [valueProp.value]: val, [trackBy.value]: val, [label.value]: val}\n    })\n\n    return uo\n  }\n\n  // no export\n  const initInternalValue = () => {\n    if (!isNullish(ev.value)) {\n      iv.value = makeInternal(ev.value)\n    }\n  }\n\n  const resolveOptions = (callback) => {\n    resolving.value = true\n\n    options.value(search.value).then((response) => {\n      ro.value = response\n\n      if (typeof callback == 'function') {\n        callback(response)\n      }\n\n      resolving.value = false\n    })\n  }\n\n  // no export\n  const refreshLabels = () => {\n    if (!hasSelected.value) {\n      return\n    }\n\n    if (mode.value === 'single') {\n      let newLabel = getOption(iv.value[valueProp.value])[label.value]\n\n      iv.value[label.value] = newLabel\n\n      if (object.value) {\n        ev.value[label.value] = newLabel\n      }\n    } else {\n      iv.value.forEach((val, i) => {\n        let newLabel = getOption(iv.value[i][valueProp.value])[label.value]\n\n        iv.value[i][label.value] = newLabel\n\n        if (object.value) {\n          ev.value[i][label.value] = newLabel\n        }\n      })\n    }\n  }\n\n  const refreshOptions = (callback) => {\n    resolveOptions(callback)\n  }\n\n  // no export\n  const makeInternal = (val) => {\n    if (isNullish(val)) {\n      return mode.value === 'single' ? {} : []\n    }\n\n    if (object.value) {\n      return val\n    }\n\n    // If external should be plain transform\n    // value object to plain values\n    return mode.value === 'single' ? getOption(val) || {} : val.filter(v => !! getOption(v)).map(v => getOption(v))\n  }\n\n  // ================ HOOKS ===============\n\n  if (mode.value !== 'single' && !isNullish(ev.value) && !Array.isArray(ev.value)) {\n    throw new Error(`v-model must be an array when using \"${mode.value}\" mode`)\n  }\n\n  if (options && typeof options.value == 'function') {\n    if (resolveOnLoad.value) {\n      resolveOptions(initInternalValue)\n    } else if (object.value == true) {\n      initInternalValue()\n    }\n  }\n  else {\n    ro.value = options.value\n\n    initInternalValue()\n  }\n  \n  // ============== WATCHERS ==============\n\n  if (delay.value > -1) {\n    watch(search, (query) => {\n      if (query.length < minChars.value) {\n        return\n      }\n\n      resolving.value = true\n\n      if (clearOnSearch.value) {\n        ro.value = []\n      }\n      setTimeout(() => {\n        if (query != search.value) {\n          return\n        }\n\n        options.value(search.value).then((response) => {\n          if (query == search.value || !search.value) {\n            ro.value = response\n            pointer.value = fo.value.filter(o => o.disabled !== true)[0] || null\n            resolving.value = false\n          }\n        })\n      }, delay.value)\n\n    }, { flush: 'sync' })\n  }\n\n  watch(ev, (newValue) => {\n    if (isNullish(newValue)) {\n      iv.value = makeInternal(newValue)\n      return\n    }\n\n    switch (mode.value) {\n      case 'single':\n        if (object.value ? newValue[valueProp.value] != iv.value[valueProp.value] : newValue != iv.value[valueProp.value]) {\n          iv.value = makeInternal(newValue)\n        }\n        break\n\n      case 'multiple':\n      case 'tags':\n        if (!arraysEqual(object.value ? newValue.map(o => o[valueProp.value]) : newValue, iv.value.map(o => o[valueProp.value]))) {\n          iv.value = makeInternal(newValue)\n        }\n        break\n    }\n  }, { deep: true })\n\n  if (typeof props.options !== 'function') {\n    watch(options, (n, o) => {\n      ro.value = props.options\n\n      if (!Object.keys(iv.value).length) {\n        initInternalValue()\n      }\n\n      refreshLabels()\n    })\n  }\n\n  return {\n    fo,\n    filteredOptions: fo,\n    hasSelected,\n    multipleLabelText,\n    eo,\n    extendedOptions: eo,\n    fg,\n    filteredGroups: fg,\n    noOptions,\n    noResults,\n    resolving,\n    busy,\n    select,\n    deselect,\n    remove,\n    selectAll,\n    clear,\n    isSelected,\n    isDisabled,\n    isMax,\n    getOption,\n    handleOptionClick,\n    handleGroupClick,\n    handleTagRemove,\n    refreshOptions,\n    resolveOptions,\n  }\n}"]},"metadata":{},"sourceType":"module"}